Acessar a aplicação: http://localhost:8080/
Acessando mapeando o usuario: http://localhost:8080/usuario/ 
   
   
   Evolução dos Serviços

                                 [REST]
                          A era da arquitetura REST 
                       A implementações do REST são o RestFull
                       Microserviços com responsabilidades definidas

                              ^                       ^
                              |                       |
                              |         [SOA]         |
                       Arquitetura Orientado a Serviços (SOA)
                          Comunicação em XML usando SOAP
                              (Extremamente Complexo)
                         
                              ^                       ^
                              |                       |
                              |                       |
                       Sistemas que trocavam informações tinham a 
                 mesma rotina escrita várias vezes por equipes diferentes 
                          (Bagunça na troca de informações)



REST (Representational State Transfer) é um estilo arquitetural usado para projetar sistemas de software distribuídos, especialmente aqueles que envolvem a 
comunicação entre sistemas na web. 


No estilo REST, os recursos são expostos através de URLs (Uniform Resource Locators) e são acessados por meio de operações HTTP, como GET, POST, PUT e DELETE. 
Cada recurso é identificado de forma única por sua URL e pode representar uma entidade de negócio, como um usuário, um produto ou uma postagem em um blog.

Os princípios básicos do REST incluem:

 -> Protocolo HTTP: O REST utiliza o protocolo HTTP como sua base de comunicação. Isso significa que ele aproveita os métodos e códigos de status HTTP, como GET para 
    recuperar um recurso, POST para criar um recurso, PUT para atualizar um recurso e DELETE para remover um recurso.
    Get - Anotação Spring @GetMapping - Pedido para recuperar dados.

 -> Stateless: As solicitações enviadas para um serviço REST devem conter todas as informações necessárias para processá-las. O servidor não deve manter nenhum estado 
    sobre o cliente entre as solicitações, ou seja, não pode ter sessões amarradas. Cada solicitação é tratada de forma independente.
    
    Exemplificando: Diagmos que você é um usuário e se logou e foi feito uma autenticação (login e senha), porém nessa parte em API RestFull entra a  
                    autenticação por tokken (código criptografado) que fica colocado no lado do navegador do usuário e toda vez que o usuário for fazer uma 
                    requisição, por exemplo, salvar um produto, esse tokken (código de validação) que é tipo uma autorização do usuário que tem que ser mandada para 
                    a API o tokken e os produtos salvos do usuário que você quer gravar no BD, então esse processo vai ser feito, ou seja, gravado os dados e gerando
                    a resposta ao usuário que foi salvo o produto com sucesso. Portanto, as sessões não podem ser amarradas, o cliente já tem que ter todos os dados
                    em mãos (na requisição), como o login, a senha, o tokken de validação e os dados para salvar, lembrando, que esses dados virá pela requisição, 
                    logo, o servidor não poderá está dependendo do cliente, esperando-o para autorizá-lo para tais ações.

 -> Operações CRUD: O REST mapeia as operações CRUD (Create, Read, Update, Delete) para os métodos HTTP correspondentes. Por exemplo, o POST é usado para criar um novo
    recurso, o GET é usado para ler um recurso, o PUT é usado para atualizar um recurso existente e o DELETE é usado para remover um recurso.
    
    POST - Anotação Spring @PostMapping - Enviar dados para processar
    PUT - Anotação Spring @PutMapping - Enviar dados para atualizar
    DELETE - Anotação Spring @DeleteMapping - Deletar o registro

 -> Representações: Os recursos em um serviço REST podem ser representados em diferentes formatos, como XML, JSON ou HTML. O cliente pode especificar o formato desejado 
    usando os cabeçalhos HTTP apropriados.

 -> URIs como identificadores de recursos: Cada recurso em um serviço REST é identificado por uma URL única. As URLs são usadas para acessar e manipular os recursos 
    através das operações HTTP.


RESTFull é um termo usado para descrever um serviço web que segue os princípios do estilo arquitetural REST. Um serviço RESTful é aquele que adere às diretrizes e 
boas práticas do REST, fornecendo uma interface consistente e previsível para interações entre sistemas.

[EndPoinnts]
Endpoints são os pontos de extremidade de um serviço web ou API (Interface de Programação de Aplicativos). Eles são as URLs (Uniform Resource Locators) específicas 
usadas para acessar recursos ou executar operações em um serviço web.

Em um serviço web, os endpoints são definidos para cada recurso disponível, indicando a localização e os métodos HTTP permitidos para interagir com esse recurso. 
Cada endpoint geralmente corresponde a uma operação específica que pode ser realizada no serviço.

Por exemplo, considere uma API de um sistema de gerenciamento de usuários. Alguns exemplos de endpoints seriam:

 ->  `/users`: Endpoint para listar todos os usuários registrados. Neste caso, provavelmente o método HTTP utilizado seria o GET.

 ->  `/users/{id}`: Endpoint para obter informações sobre um usuário específico. O parâmetro `{id}` indica que o endpoint espera o ID do usuário como parte da URL. 
     O método HTTP utilizado aqui também seria o GET.

 -> `/users/{id}`: Endpoint para atualizar as informações de um usuário específico. O método HTTP utilizado seria o PUT ou o PATCH.

 -> `/users/{id}`: Endpoint para excluir um usuário específico. O método HTTP utilizado seria o DELETE.

Cada endpoint é uma rota específica dentro da API que determina a ação a ser executada e os recursos envolvidos. Os endpoints são acessados através de uma combinação 
da URL base do serviço e da rota específica definida para cada recurso.

Ao projetar uma API, os endpoints devem ser bem definidos e seguir as convenções estabelecidas para garantir uma interface clara e consistente para os clientes que 
desejam interagir com o serviço web.

Exemplificando: Tem o sistema de mercado e você quer disponibilizar em uma arquitetura de API, logo você terá que reescrever as regras de negócio da usa linguagem 
de programação e que dê suporte a web. Você vai criar o seu projeto em forma de API, colocar num servidor de hospedagem e integrar o Banco de Dados e fazer as suas 
interfaces (tela) para o usuário acessar. O usuário só vai fazer as requisições para acessar as informações do servidor e retornando para o usuário.

                                 < Integração de vários projetos em uma API >

  --------------------------    Requisições (endpoints)
  | [ Servidor Hospedagem ] |  <------------------------ [ sistema web ]
  |         +               |  <------------------------ [ sistema desktop ]    <----------------->[ Usuário ]
  |    [ Banco de Dados ]   |  <------------------------ [ aplicativo mobile ]
  |-------------------------|
     Projeto em API
      WebServices
   

                       < Sistema em Arquitetura em REST / RestFull >


           [ Front End ]                                           [ Back End ]
               JQuery        Pedido feito para o servidor             Java
               PrimeUI    -------------------------------------->     PHP
               Angular                                                C#
               VueJS                Ajax + JSON                       Ruby
               React         Retorno de dados em JSON                 Python
               Outros    <---------------------------------------     Go
                                                                      Outros

OBS. Só o JSON é a resposta do pedido de processamento do servidor. Não retorna mais numa página com dados, agora é retornado somente o JSON.
     Ou seja, é pedido e resposta em ajax e JSON, com isso, não deixa a arquitetura amarrada, contudo é possível construir a nossa estrutura 
     com back-end em qualquer uma das liguagens dita acima e do outro lado, no front-end, também qualquer uma das linguagens dita acima. Outro,
     detalhe é que é possível trocar a tecnologia tanto do front-end quanto do back-end sem que sofra problemas de compatibilidade. É possível 
     também reutilizar tanto o front-end quanto o back-end para conectar com vários front-end ou vários back-end.
 
Benefícios: 
    -> Reutilização de Códigos;
    -> Acessível por qualquer tecnologia;
    -> Baixo consumo do servidor, ou seja, (1) faz a requisição (2) o ajax processo (3) devolve a requisição (4) Finish;
    -> Fácil Manutenção;
    -> Fácil implementação de recursos;
    -> Front-End desamarrado com o back-end, ou seja, é possível trocar a tecnologia do front-end sem que sofra alterações no back-end;
        OBS. Por exemplo, o MVC é uma arquitetura amarrada, pois precisa dessa integração entre o front-end e back-end, ou seja, em MVC 
             tem que retornar uma página junto com os dados.
    -> Back-End desamarrado com o front-end, ou seja, é possível trocar a tecnologia do back-end sem que sofra alterações no front-end;
    -> Alta escalabilidade;
    -> Outros.

                                                     < Modelagem Correta de URIs >

OBS. URI - É como será acessado os nossos métodos RestFull.

OBS. As requisições abaixos serão acessadas por um navegador pelo um framework em javascript. Serão passados um paramêtro (verbo) HTTP e a URI que 
     definirá a ação.



            [ URI criada de forma ERRADA ]                                          [ URI criada de forma CERTA ]
   
                     RPC (POX)                                                                   REST
-----------------------------------------------------                   -----------------------------------------------------
| Verbo HTTP  |       URI           |      Ação      |                  | Verbo HTTP  |       URI           |      Ação      |
-----------------------------------------------------                    -----------------------------------------------------
|    GET      | /buscarCliente/1    |   Visualizar   |                  |    GET      |      /cliente/1     |   Visualizar   |
-----------------------------------------------------                    -----------------------------------------------------
|   POST      | /salvarCliente/1    |   Criar        |                  |   POST      |      /cliente       |   Criar        |
-----------------------------------------------------                    -----------------------------------------------------
|   POST      | /alterarCliente/1    |   Alterar     |                  |   PUT       |      /cliente/1     |   Alterar     |
-----------------------------------------------------                    -----------------------------------------------------
| GET/POST    | /deletarCliente/1    |   Remover     |                  |   DELETE    |       /cliente/1    |   Remover     |
-----------------------------------------------------                    -----------------------------------------------------

OBS. A implementação feita de forma errada pode gerar 
     quebra do sistema, de padrões, sem falar que também
     não pode expor a sua URI para possíveis invasores mal
     intencionados.

         @RestController
         @RestMapping("/cliente")
         public class PessoaController{
              
                @GetMapping("/{cpf}")
                public ResponseEntity<Pessoa> buscarPessoa(@PathVariable("cpf") String cpf){
                
                       System.out.println("Aqui processa a consulta no banco de dados");

                       return new ResponseEntity<Pessoa>(new Pessoa(), HttpStatus.OK);
                }
        }


                                      < Regras da API RestFull >

 1. Tem que existir os dois papéis, o cliente (Navegador - front-end) e o servidor (API - back-end).
 
 2. Stateless, o sistema não pode ter sessões amarradas/ criadas para o cliente e as requisições tem que todos os dados 
    para o processo ser realizado e a resposta ser completa.

 3. Precisa permitir que o cache seja feito caso necessário.

 4. Interface uniforme - a API não pode fazer distinção de clientes, não pode diferenciar e processar algo diferente para 
    o navegador, desktop ou mobile. Ou seja, a API não pode saber qual é o tipo de cliente, se ele é um navegador, ou um desktop
    ou um mobile.

 5. Sistemas em camadas, entre o cliente e a API deves ser possível adicionar algum serviço como log da aplicação.

 6. Código sobre demanda, por exemplo, o javascript importado direto do servidor da API.

-------------------------------------------------//------------------------------------------------------------

Mapeamentos:

 1. @EntityScan(basePackages = {"projeto.api.rest.model"})
    Vai ler todas as classes que estiverem nesse pacote de modelo para criar automaticamente no banco de dados.
    
 2. @ComponentScan(basePackages = {"projeto.*"})
    Para injeção de dependencia para o Spring controlar todos os nossos objetos. Vai entrar em todas as pastas 
    denominado 'projeto' e vai sair varrendo configurando todo o nosso projeto automaticamente em relação a 
    injeção de dependencia.
    
 3. @EnableJpaRepositories(basePackages = {"projeto.api.rest.repository"})
   Habilitar a parte de repositório para as funcionalidades do CRUD 
    
 4. @EnableTransactionManagement
   Corresponde no controle das transações no banco de dados, transaçoes na hora de inserir, deletar, ...
   São as gerencias de transações.
   
 5. @EnableWebMvc
   Caso eu queira trabalhar com a estrutura MVC - ativa a parte de MVC.
   
 6. @RestController
   Para saber que é um projeto Rest e que é para retornar JSON nas requisições.
   
 7. @EnableAutoConfiguration
    Para ativar todas essas configurações de mapeamento e manter tudo funcionando.
 
    
 Todas essas anotações é o suficiente para manter o funcionamento de projetos Rest Spring Boot.
 
 --------------------------------------------- // -----------------------------------------------------------

Tem que aplicar essas propriedades no application.properties para corrigir esse erro: 
java.sql.SQLFeatureNotSupportedException - é um erro que não prejudica a aplicação, no caso, é um 
erro de conexão de JDBC. Portanto, para resolver basta adicionar as duas propriedades abaixo.

propriedades:

spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults = false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

IMPORTANTE!!!
Link da documentação do application.properties:
https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html


-------------------------------------------- // -------------------------------------------------------------

Vale ressaltar que vamos utilizar as bibliotecas javax para as funcionalidades do JPA. Porém ao criar o projeto por
padrão são adicionados as bibliotecas do jakarta. Logo, para fazer essa remorção do jakarta temos que mudar a versão
do Spring na tag parent para 2.1.2.RELEASE no arquivo pom.xml, dessa forma o javax será provido em seu projeto sem ser 
necessário adicionar nenhuma dependência extra! 
Exemplificando - lá no pom.xml

<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.1.RELEASE</version>
		<relativePath /> <!-- lookup parent from repository -->
</parent>

Outro Detalhe: Modifiquei para java 1.8. 

---------------------------------------------- // ---------------------------------------------------------------
Exemplificando a codificação: 

1. `@RestController`: É uma anotação usada no Spring Boot para indicar que essa classe é um controlador REST, responsável por lidar com as 
    solicitações HTTP e retornar as respostas adequadas.

2. `@RequestMapping(value = "/usuario")`: É uma anotação que especifica o caminho base para todas as solicitações HTTP manipuladas por esse 
    controlador. Nesse caso, todas as solicitações começando com "/usuario" serão tratadas por este controlador.

3. `public class IndexController`: É a definição da classe do controlador.

4. `@GetMapping(value = "/", produces = "application/json")`: É uma anotação que especifica que esse método será acionado por uma solicitação GET HTTP 
    para a rota especificada. Neste caso, o método `init` será acionado quando a solicitação for enviada para "/usuario/".

5. `public ResponseEntity init(@RequestParam(value = "nome") String nome)`: É a definição do método `init`, que recebe um parâmetro chamado "nome" através 
    de uma solicitação GET. O valor desse parâmetro é armazenado na variável `nome` do tipo `String`. O retorno do método é uma instância de `ResponseEntity`, 
    que é uma classe que representa uma resposta HTTP personalizada.

6. `System.out.println("Parâmetro sendo recebido " + nome);`: Essa linha imprime no console uma mensagem contendo o valor do parâmetro "nome" recebido na 
    solicitação GET.

7. `return new ResponseEntity("Olá usuário Rest Spring Boot, seu nome é " + nome, HttpStatus.OK);`: Retorna uma nova instância de `ResponseEntity` com uma 
    mensagem de saudação personalizada, que inclui o valor do parâmetro "nome" recebido. O status HTTP retornado é "OK" (código 200).

Em resumo, esse script define um controlador REST que recebe uma solicitação GET em "/usuario/" com um parâmetro "nome" e retorna uma resposta HTTP com uma 
mensagem de saudação personalizada. O valor do parâmetro "nome" é exibido no console antes de retornar a resposta.

Passando o parametro da aplicação como exemplo: http://localhost:8080/usuario/?nome=Daniel

Podemos utilizar o 'defaultValue' para caso onde o cliente esquece de preencher o valor, logo se o cliente esquece de informar o valor,
o serviço irá pegar esse valor default, podendo retornar como resultado para o cliente dando-lhe um aviso para ele.

Podemos utilizar o 'required' como 'false' que torna não obrigatorio o valor a ser passado por parametro. Logo, como o parametro não é
obrigatório, ele assume o valor de null. Lembrando que para o valor 'true' torna obrigatorio o valor do parametro a ser passado.

Passando o parametro da aplicação como exemplo: http://localhost:8080/usuario/?nome=Daniel&salario=5000

------------------------------------------------------------------- // ------------------------------------------------------------

public ResponseEntity<Usuario> init(@PathVariable(value = "id") Long id): Esse é o método init, que recebe um parâmetro id através 
de uma variável de caminho (path variable) usando a anotação @PathVariable. A anotação @PathVariable indica que o valor do id será 
extraído do caminho da URL. O tipo do parâmetro é Long. O retorno do método é uma instância de ResponseEntity que encapsula um 
objeto do tipo Usuario.

Para testar vamos inserir alguns valores no banco de dados:
INSERT INTO public.usuario(
            id, login, nome, senha)
    VALUES (1, 'daniel', 'Daniel', '123');

INSERT INTO public.usuario(
            id, login, nome, senha)
VALUES (2, 'biana', 'Biana', '123');

INSERT INTO public.usuario(
            id, login, nome, senha)
VALUES (3, 'walter', 'Walter', '123');

uri: http://localhost:8080/usuario/1

------------------------------------------------------------------- // ------------------------------------------------------------
Exemplificando a codificação: 

1. `@PostMapping(value = "/", produces = "application/json")`: Essa é uma anotação utilizada no Spring Boot para mapear o método 
   `cadastrar` a uma solicitação HTTP POST. Ela especifica que o método será acionado quando uma solicitação POST for enviada para 
    a rota "/". A opção `produces = "application/json"` indica que a resposta será em formato JSON.

2. `public ResponseEntity<Usuario> cadastrar(@RequestBody Usuario usuario)`: Esse é o método `cadastrar` que recebe um objeto 
   `Usuario` como parâmetro. A anotação `@RequestBody` indica que o objeto `Usuario` será extraído do corpo (body) da solicitação 
    POST. O retorno do método é uma instância de `ResponseEntity` que encapsula um objeto do tipo `Usuario`.

3. `Usuario usuarioSalvo = usuarioRepository.save(usuario)`: Nesta linha, o objeto `usuario` recebido como parâmetro é salvo no 
    banco de dados usando o método `save` do objeto `usuarioRepository`. O método `save` retorna o objeto `Usuario` salvo, que é 
    armazenado na variável `usuarioSalvo`.

4. `return new ResponseEntity<Usuario>(usuarioSalvo, HttpStatus.OK)`: Aqui, é criada uma instância de `ResponseEntity`, passando o 
   objeto `usuarioSalvo` como primeiro argumento e `HttpStatus.OK` como segundo argumento. O `HttpStatus.OK` indica que a solicitação 
   foi bem-sucedida, com código de status HTTP 200. O objeto `usuarioSalvo` será retornado como resposta da solicitação POST.

Em resumo, esse script define um método `cadastrar` que é acionado por uma solicitação HTTP POST na rota "/". O método recebe um 
objeto `Usuario` no corpo da solicitação, salva esse objeto no banco de dados e retorna uma resposta HTTP com o objeto `Usuario` 
salvo e o código de status HTTP 200 (OK).

------------------------------------------------------------------- // ------------------------------------------------------------

Configuração de contexto da nossa aplicação, ou seja, seria a nossa url do projeto. O contexto é configurado no application.properties.
Propriedade:
server.servlet.context-path=/projetospringrestapi

Portanto, o nosso contexto ficou assim agora:
http://localhost:8080/projetospringrestapi/
http://localhost:8080/projetospringrestapi/usuario/


---------------------------------------------------------------------- // -------------------------------------------

Vamos criar um Builder para startizar o nosso projeto automaticamente, para fazer isso vamos gerar um Jar executável 
da Aplicação Spring Boot.

1º Vamos modificar o nosso packaging de 'war' para jar. Logo vai ficar assim:
<packaging>jar</packaging>

2º Vamos copiar o caminho de endereço a partir da pasta 'target', para isso:
   clica com o botão direito em cima da pasta target > properties > Resources > Location: Show In System Explorer (copia o caminho da pasta )
   Por exemplo: C:\Users\d4nan\git\repository12\projetospringrestapi
   
3º Vamos abrir o prompt de comando: cmd

4º Vamos acessar essa pasta, por exemplo:
   cd C:\Users\d4nan\git\repository12\projetospringrestapi
   
5º Vamos criar a Builder para gerar o jar executável
   Comando: mvn package
   
   IMPORTANTE!!! Estava dando erro por causa do arquivo de teste, para resolver esse erro vamos fazer um skip para pular
   esse arquivo de teste.
   Comando:  mvn clean package -DskipTests
   
6º Clica na pasta target ou no projeto e aperta o F5 para atualizar, vai ser criado o jar do projeto na pasta target.   
   
7º Vamos agora executar o jar para que ele fique executável para a aplicação Spring Boot.
   No prompt de comando (cmd) vamos acessar agora a pasta target.
   Comando: cd target
   
   Depois vamos inserir o comando do jar criado: java -jar <nome do jar criado>
   OBS: Podemos acessar esse o jar clicando em cima 'projetospringrestapi-0.0.1-SNAPSHOT.jar' e com o botão 
        direito do mouse vai em properties > Resources > Location: Show In System Explorer (copia o nome do jar do projeto)  
   Comando: java -jar projetospringrestapi-0.0.1-SNAPSHOT.jar 
   
   Vale ressaltar se fechar o prompt de comando (cmd) vai morrer o processo.
   
   Para executar o processo de novo temos que:
   Acessar o prompt de comando (cmd) e acessar a pasta target:
   comando: cd C:\Users\d4nan\git\repository12\projetospringrestapi\target
   executar o jar comando: java -jar projetospringrestapi-0.0.1-SNAPSHOT.jar
   
   Podemos também executar o processo diretamente no jar criado, porém NÃO É ACONSELHÁVEL, pois não terá o prompt 
   para visualzar os logs, uma vez que precisamos dele para descobrir erros que podem ocasionar na nossa api quando
   estiver implementando. Lembrando que para executar o jar criado basta ir na pasta onde ele se encontra e clicar
   nele para ser executado. (caminho: C:\Users\d4nan\git\repository12\projetospringrestapi\target)
   
   Por isso o correto é acessar pelo prompt de comando e acessar a pasta target:
   comando: cd C:\Users\d4nan\git\repository12\projetospringrestapi\target
   executar o jar comando: java -jar projetospringrestapi-0.0.1-SNAPSHOT.jar 
   
   É possível acessar a sua API por outros sistemas ou pelo mobile basta utilizar o link - seria uma intranet
   simulando um servidor:
   http://<ipconfig>:8080/projetospringrestapi/
   
   --------------------------------------------------- // ------------------------------------------------------------------
   
Criando o POST no postman:
   
{
   "id": "",
   "login": "joao",
   "senha": "123",
   "nome": "João",
   "telefones": [{"id":"", "numero":"(21) 9944-9223"}, {"id":"", "numero":"(21) 9256-3990"}]
}

Exemplo de delete no postman:
http://localhost:8080/projetospringrestapi/usuario/20/

Exemplo atualizar (PUT) no postman: http://localhost:8080/projetospringrestapi/usuario/

Alterando apenas os dados do usuário:
{
    "id": 35,
    "login": "vanessa",
    "senha": "123",
    "nome": "Vanessa",
    "telefones": [
        {
            "id": 36,
            "numero": "(21) 9005-9677"
        }
    ]
}


Alterando add um novo telefone:

{
    "id": 37,
    "login": "bolsonaro",
    "senha": "123",
    "nome": "Bolsonaro",
    "telefones": [
        {
            "id": 38,
            "numero": "(21) 9889-9234"
        },
        {
            "id": "",
            "numero": "(21) 9899-9004"
        }
    ]
}

OBS. Também é possível alterar deletando um telefone.

 --------------------------------------------------- // ------------------------------------------------------------------
 
Cross Origin - Controle de acesso a API
 
Por motivos de segurança, os navegadores proíbem chamadas AJAX para recusrsos que residem fora da origem atual.
 
Como uma API Rest é feita para que vários clientes possam acessar, então surgeo controle de acesso denominado CORS.
 
Podemos fazer bloqueios e liberações bem customizadas para cada end-point, para cada controller REST e seus end-points ou até
 mesmo para todo o projeto e seus end-points. 
 
O controle de acesso a recursos de API através da política de mesma origem (Same-Origin Policy) é uma medida de segurança 
implementada pelos navegadores para proteger os usuários contra ataques de scripts maliciosos que poderiam ser executados em sites 
de terceiros. Essa política impede que scripts em um domínio acessem recursos em outro domínio, a menos que os domínios envolvidos 
estejam explicitamente configurados para permitir tal acesso.

No entanto, em alguns casos, pode ser necessário permitir solicitações de origens diferentes, o que é conhecido como Cross-Origin 
Resource Sharing (CORS), ou Controle de Acesso a Origem Cruzada. Isso é comum em aplicativos que expõem APIs para consumo por 
clientes que são hospedados em domínios diferentes. O CORS permite que o servidor especifique quais origens têm permissão para 
acessar seus recursos através de cabeçalhos HTTP.

O Spring Security oferece suporte ao CORS, permitindo que você controle o acesso a recursos de API a partir de origens diferentes. 
Para configurar o controle de acesso a origem cruzada no Spring Security, você pode usar a classe CorsConfiguration para definir a 
política de CORS e, em seguida, configurar um CorsFilter para aplicar essa política.

A configuração básica do CORS no Spring Security envolve a definição de quais origens são permitidas (allowedOrigins), quais 
métodos HTTP são permitidos (allowedMethods), quais cabeçalhos podem ser incluídos nas solicitações (allowedHeaders), se as 
credenciais podem ser enviadas (allowCredentials), entre outras opções. Você também pode definir valores específicos para 
diferentes caminhos da API, se necessário.

Passos:


Vamos criar um arquivo index.html e dentro do index.html vamos add uma JQuery CDN para pegar o código de integração, é para garantir o 
funcionamento do JQuery na  nossa página html. Esse código vai ser pego no endereço:
(https://releases.jquery.com/) na opção 'uncompressed' e colado dentro da tag <head>.

Vamos acessar o index.html através do caminho pelo 'properties':
"file:///C:/Users/d4nan/git/repository12/projetospringrestapi/src/main/webapp/index.html"

OBS. Vai abrir uma página em branco.

Se inspecionar (F12) o navegador você visualizará que houve um bloqueio do arquivo index.html pela a política do CORS. Msg gerada:

Access to XMLHttpRequest at 'http://localhost:8080/projetospringrestapi/usuario/' from origin 'null' has been blocked by CORS policy: 
No 'Access-Control-Allow-Origin' header is present on the requested resource.


Cross Origin - Configuração em controler especifico

Se estiver apenas a anotação '@CrossOrigin' vai permitir que qualquer sistema possa fazer uma requisição, uma vez que por padrão vem 
com o asteristico (*), que permite para todos. Vale ressaltar que podemos configurar essa anotação através das 'origins', podendo 
passar quantas origins quiser. Essa origin permite liberar o acesso para o dominio que estiver determinado por ela. Ou seja, vou estar
amarrando o dominio (servidor) com a minha API, permitindo que apenas o que está configurado na origins possa acessar o meu controller de API, 
ou seja, que apenas esse controller de API só iria receber requisições do que está configurado na origins.

Portanto, a anotação @CrossOrigin é uma anotação fornecida pelo Spring Framework para configurar o suporte ao Cross-Origin Resource 
Sharing (CORS) em um controlador de API ou método específico. Essa anotação permite que você controle o acesso a recursos de API a 
partir de origens diferentes.

Ao usar a anotação @CrossOrigin em um controlador ou método, você pode especificar quais origens são permitidas, quais métodos HTTP 
são permitidos, quais cabeçalhos podem ser incluídos nas solicitações, se as credenciais podem ser enviadas e outras opções relacionadas 
ao CORS.

Você também pode usar a anotação @CrossOrigin no nível do controlador para aplicar a mesma configuração a todos os métodos do 
controlador. Nesse caso, a configuração definida no nível do controlador pode ser substituída por configurações específicas de métodos, 
se necessário.

Além de especificar as origens permitidas e os métodos HTTP permitidos, a anotação @CrossOrigin oferece outras opções, como 
allowedHeaders para especificar quais cabeçalhos são permitidos, exposedHeaders para especificar quais cabeçalhos são expostos nas 
respostas, allowCredentials para permitir o envio de credenciais, maxAge para especificar o tempo máximo de cache das configurações 
CORS, entre outras.

É importante lembrar que ao usar a anotação @CrossOrigin, você precisa considerar as implicações de segurança e garantir que seu 
aplicativo esteja adequadamente protegido contra ataques. Você deve configurar as opções de CORS de acordo com suas necessidades 
específicas e garantir que seu aplicativo esteja protegido contra vulnerabilidades conhecidas associadas ao CORS.

Em resumo, a anotação @CrossOrigin é usada para configurar o suporte ao Cross-Origin Resource Sharing (CORS) em controladores de API 
do Spring. Ela permite que você especifique as origens permitidas, os métodos HTTP permitidos, os cabeçalhos permitidos e outras opções 
relacionadas ao CORS em nível de controlador ou método específico.

Como foi dito é possível especificar quais origins são permitidas, quais end-points (métodos HTTP) são permitidos, por exemplo, no 
método 'listaUsuario' vai ser permitido apenas requisições ajax que partirem do servidor 'https://www.google.com/' e 
'https://www.w3schools.com/' que vão poder acessar o método 'listaUsuario' e consumir os seus dados.

O objetivo da CrossOrigin é para pemitir apenas acesso(s) a domínio(s) que está(ão) estipulado em sua regra de negócio, ninguém poderá 
saber que existe essa API para quem não está definido em sua regra de negócio, somente saberá aqueles que estarão configurados através 
da 'origins' que estarão definidos em sua regra de negócio, somente esses poderão consumir os dados da sua API, ou seja, o intuito é 
amarrar a origem e o destino.


Cross Origin - Configuração centralizada (Para Mapeamento Global que refletem em todo o sistema)

O método addCorsMappings é um método fornecido pela interface WebMvcConfigurer do Spring Framework. Esse método é usado para adicionar 
configurações de CORS (Cross-Origin Resource Sharing) ao aplicativo Spring MVC.

O CORS é uma política de segurança implementada pelos navegadores para restringir solicitações de recursos de uma origem (domínio) 
diferente. Ele impede que um script em uma página da web faça solicitações para outra origem, a menos que essa origem tenha configurado 
as permissões de acesso adequadas.

O método addCorsMappings permite que você defina mapeamentos de URL para aplicar as configurações de CORS a caminhos específicos do 
seu aplicativo. Por exemplo, você pode permitir que um caminho específico aceite solicitações de uma origem diferente.

No exemplo, dado no 'ProjetospringrestapiApplication.java' o método addCorsMappings está sendo usado para configurar o CORS para 
qualquer URL que comece com "/usuario/**". Estamos permitindo solicitações apenas da origem "https://google.com", permitindo apenas os 
métodos GET e POST, permitindo os cabeçalhos "Authorization" e "Content-Type", permitindo o envio de credenciais e definindo um 
tempo máximo de cache de 3600 segundos.

Com essa configuração, as solicitações CORS para URLs que correspondam ao padrão "/usuario/**" serão permitidas somente da origem 
especificada, com os métodos, cabeçalhos e outras configurações definidas.

É importante observar que o uso do método addCorsMappings é apenas uma forma de configurar o CORS no Spring MVC. Existem outras 
opções para configurar o CORS, como o uso da anotação @CrossOrigin em controladores individuais. Você pode escolher a opção mais 
adequada com base nas necessidades do seu aplicativo.

Em resumo, o método addCorsMappings é usado para adicionar configurações de CORS ao aplicativo Spring MVC. Ele permite definir 
mapeamentos de URL e configurar as origens permitidas, métodos HTTP permitidos, cabeçalhos permitidos, envio de credenciais e outras 
opções relacionadas ao CORS para caminhos específicos do aplicativo.

-------------------------------------------------- // -------------------------------------------------------------

Spring Security - Configurando ROLE

Bom saber - Anotações:

A anotação @SequenceGenerator é usada para gerar valores sequenciais para a chave primária da tabela. Nesse caso, a sequência é 
chamada "seq_role" e possui um valor inicial de 1 e um tamanho de alocação de 1.

sequenceName -> cria uma sequencia;
allocationSize -> seja gerado de um em um;
initialValue -> inicia com o valor 1;

Para aplicar o Spring Security vamos ter que fazer implementar uma interface 'GrantedAuthority', por padrão tem que add o método
'getAuthority()' do tipo String. Este método retorna o nome do papel, ou seja, o acesso ou a autorização, por exemplo, ROLE_GERENTE.

A classe Role implementa a interface GrantedAuthority da biblioteca Spring Security. Essa interface representa a autoridade ou papel 
de um usuário em um sistema.

O método getAuthority() é necessário para a interface GrantedAuthority e retorna o nome do papel.

Em resumo, essa classe representa uma entidade "Role" com um identificador único (id) e um nome de papel (nomeRole). A classe também 
implementa a interface GrantedAuthority para ser utilizada em um sistema de segurança, retornando o nome do papel através do método 
getAuthority().

----------------------------------------------------- // --------------------------------------------------------------------

Spring Security - Configurando Usuário

Vamos retirar o implements Serializable e colocar o 'UserDetails' que no caso já vem com um Serializable nela.

A interface `UserDetails` faz parte do framework Spring Security e é usada para representar informações sobre um usuário autenticado 
no sistema. Ela encapsula detalhes sobre o usuário, como seu nome, senha, autorizações (papéis/roles), status de conta e outras 
informações relevantes.

A principal função da interface `UserDetails` é fornecer essas informações ao Spring Security durante o processo de autenticação e 
autorização. Quando um usuário faz login no sistema, o Spring Security precisa obter os detalhes desse usuário para verificar sua 
autenticidade e determinar quais recursos e ações ele tem permissão para acessar.

A interface `UserDetails` define vários métodos que precisam ser implementados, como:

- `getUsername()`: Retorna o nome de usuário do usuário.
- `getPassword()`: Retorna a senha do usuário.
- `getAuthorities()`: Retorna uma coleção de objetos `GrantedAuthority`, que representam as autorizações ou papéis do usuário.
- `isEnabled()`: Verifica se a conta do usuário está habilitada.
- `isAccountNonExpired()`: Verifica se a conta do usuário não está expirada.
- `isAccountNonLocked()`: Verifica se a conta do usuário não está bloqueada.
- `isCredentialsNonExpired()`: Verifica se as credenciais do usuário não estão expiradas.

Além desses métodos, a interface `UserDetails` possui outros métodos relacionados a informações adicionais do usuário, como nome 
completo, e-mail, informações de contato, etc.

Ao implementar a interface `UserDetails`, você fornece ao Spring Security uma maneira de acessar e utilizar os detalhes do usuário 
durante o processo de autenticação e autorização, garantindo a segurança adequada do sistema.

Temos o método: public Collection<? extends GrantedAuthority> getAuthorities(){...}. 
Vamos analisar o que ele faz:

Este método retorna uma coleção de objetos que implementam a interface GrantedAuthority. A declaração 
Collection<? extends GrantedAuthority> indica que o método retorna uma coleção de qualquer tipo que seja ou estenda a interface 
GrantedAuthority. O uso de ? extends GrantedAuthority permite que diferentes implementações de GrantedAuthority sejam retornadas.

Vai retornar uma coleção real de autorizações. Normalmente, em um sistema real, você implementaria a lógica dentro desse método para 
recuperar as autorizações (ou papéis) do usuário. Isso pode ser feito consultando o banco de dados ou qualquer outra fonte de dados 
para obter as informações de autorização associadas ao usuário autenticado.

A idéia geral é que esse método retorne uma coleção de objetos GrantedAuthority que representam os papéis ou autorizações do usuário. 
Essas autorizações são usadas pelo Spring Security para determinar quais recursos e ações o usuário tem permissão para acessar.

Vamos entender essa anotação declarada na List<Roles> roles:

@JoinTable(
    name = "usuarios_role",
    uniqueConstraints = @UniqueConstraint(
        columnNames = {"usuario_id", "role_id"},
        name = "unique_role_user"
    ),
    joinColumns = @JoinColumn(
        name = "usuario_id",
        referencedColumnName = "id",
        table = "usuario",
        foreignKey = @ForeignKey(
            name = "usuario_fk",
            value = ConstraintMode.CONSTRAINT
        )
    ),
    inverseJoinColumns = @JoinColumn(
        name = "role_id",
        referencedColumnName = "id",
        table = "role",
        foreignKey = @ForeignKey(
            name = "role_fk",
            value = ConstraintMode.CONSTRAINT
        )
    )
)

A anotação @JoinTable é usada em mapeamentos Many-to-Many em entidades JPA para especificar a tabela de junção que será usada para 
associar duas entidades.

name = "usuarios_role": Especifica o nome da tabela de junção que será criada para associar as entidades "usuarios" e "role". Neste 
caso, a tabela será chamada "usuarios_role".

uniqueConstraints: Permite definir uma ou mais restrições de unicidade para as colunas da tabela de junção. No exemplo, é definida 
uma restrição de unicidade composta pelas colunas "usuario_id" e "role_id" e é atribuído o nome "unique_role_user" para essa restrição.

joinColumns: Especifica as colunas da tabela de junção que se referem à entidade "usuario". No exemplo, é definida uma coluna chamada 
"usuario_id" que se refere à coluna "id" da tabela "usuario". A anotação @JoinColumn também permite especificar o nome da tabela, 
caso seja diferente do nome padrão da entidade. Além disso, é definida uma restrição de chave estrangeira com o nome "usuario_fk" 
usando @ForeignKey e ConstraintMode.CONSTRAINT.

inverseJoinColumns: Especifica as colunas da tabela de junção que se referem à entidade "role". No exemplo, é definida uma coluna 
chamada "role_id" que se refere à coluna "id" da tabela "role". Assim como em joinColumns, é definida uma restrição de chave 
estrangeira com o nome "role_fk".

Essa anotação em conjunto com @ManyToMany é utilizada para estabelecer um relacionamento muitos-para-muitos entre as entidades 
"usuarios" e "role" através de uma tabela de junção intermediária chamada "usuarios_role". Essa tabela armazena os registros que 
associam um usuário a um ou mais papéis. As colunas "usuario_id" e "role_id" na tabela de junção são usadas para referenciar os 
identificadores das entidades "usuario" e "role", respectivamente.

-------------------------------------------------------- // -------------------------------------------------------------

Para criar o Service, vamos implementar a interface UserDetailsService que faz parte do framework de segurança do Spring, que 
é amplamente utilizado no desenvolvimento de aplicativos Java. Essa interface é uma parte fundamental do subsistema de 
autenticação e autorização do Spring Security.

A interface UserDetailsService é responsável por carregar os detalhes do usuário durante o processo de autenticação. O Spring 
Security utiliza essa interface para obter informações sobre o usuário, como nome de usuário, senha e permissões, a partir de 
uma origem de dados, como um banco de dados ou um serviço web.

A interface UserDetailsService define um único método: public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException{...}

O método loadUserByUsername recebe um nome de usuário como parâmetro e retorna um objeto do tipo UserDetails. A implementação 
desse método deve buscar as informações do usuário com base no nome de usuário fornecido e retornar um objeto UserDetails 
populado com essas informações.

A interface UserDetails é outra parte importante do Spring Security. Ela define os detalhes do usuário, incluindo nome de 
usuário, senha, autoridades (ou seja, as permissões associadas ao usuário) e outros atributos relevantes.

Ao implementar a interface UserDetailsService, você pode personalizar como os detalhes do usuário são obtidos e carregados no 
processo de autenticação do Spring Security. Isso permite que você integre o Spring Security com diferentes origens de dados, 
como um banco de dados relacional, um serviço web RESTful ou qualquer outra fonte personalizada.

A implementação da interface UserDetailsService é geralmente feita em conjunto com a configuração do Spring Security, onde 
você pode definir as regras de autenticação e autorização, como quais usuários têm acesso a determinados recursos e como as 
senhas são armazenadas e comparadas.

Em resumo, a interface UserDetailsService é uma parte essencial do subsistema de segurança do Spring, permitindo que você 
personalize como os detalhes do usuário são obtidos durante o processo de autenticação.

Pequeno apanhado sobre a anotação: @Autowired

A anotação @Autowired é uma anotação do Spring Framework que é usada para realizar a injeção de dependência automática. 
A injeção de dependência é um padrão de design que permite que os objetos obtenham as dependências de que precisam a partir de 
uma fonte externa, em vez de criá-las internamente.

Quando você usa a anotação @Autowired em uma classe, o Spring irá procurar por uma instância adequada do tipo especificado e a 
injetará automaticamente no ponto apropriado. Isso elimina a necessidade de criar manualmente as dependências e facilita a 
configuração e a manutenção do código.

A anotação @Autowired pode ser aplicada em diferentes níveis, como campos, construtores e métodos. 
Aqui está o exemplo da injeção em campos: 

@Autowired
UsuarioRepository usuarioRepository;

Nesse caso, o Spring irá procurar por um bean (instância gerenciada pelo Spring) do tipo UsuarioRepository e atribuirá 
automaticamente essa instância ao campo usuarioRepository.

------ // ---------

Para injeção de construtores - exemplo qualquer:

private final UserService userService;

@Autowired
public MyController(UserService userService) {
    this.userService = userService;
}

Ao usar a anotação @Autowired em um construtor, o Spring irá procurar por um bean do tipo UserService e passará automaticamente 
essa instância como argumento para o construtor. Isso é conhecido como injeção de dependência por construtor.

------ // ---------

Para injeção de métodos - exemplo qualquer:

@Autowired
public void setUserService(UserService userService) {
    this.userService = userService;
}

A anotação @Autowired também pode ser usada em métodos, permitindo que o Spring injete automaticamente a dependência no método.

Além disso, é possível combinar a anotação @Autowired com outras anotações, como @Qualifier para especificar qual bean deve 
ser injetado quando existem várias opções disponíveis.

É importante observar que a anotação @Autowired requer a configuração adequada do Spring para funcionar corretamente. Você 
precisa configurar o contêiner do Spring para escanear as classes e gerenciar as dependências corretamente, geralmente por 
meio de arquivos de configuração ou usando a anotação @ComponentScan em uma classe de configuração.

Em resumo, a anotação @Autowired do Spring Framework é usada para realizar a injeção de dependência automática, permitindo 
que as dependências sejam injetadas automaticamente em campos, construtores ou métodos, facilitando a configuração e a 
manutenção do código.

------------------------------------------------------------- // ------------------------------------------------------------

A classe `WebSecurityConfigurerAdapter` é uma classe fornecida pelo Spring Security, que simplifica a configuração do sistema de 
segurança em um aplicativo web. Ela serve como uma base para criar uma configuração personalizada do Spring Security para proteger 
seus endpoints, autenticar usuários e aplicar regras de autorização.

Ao estender a classe `WebSecurityConfigurerAdapter` e anotar a classe derivada com `@Configuration`, você pode personalizar o 
comportamento do Spring Security no seu aplicativo web. A classe `WebSecurityConfigurerAdapter` fornece métodos que você pode 
sobrescrever para definir diferentes aspectos da configuração de segurança.

Aqui estão alguns dos métodos mais comuns que você pode sobrescrever ao estender `WebSecurityConfigurerAdapter`:

-> `configure(HttpSecurity http)`: Este método permite configurar as regras de segurança para diferentes URLs, como definir permissões 
   de acesso, exigir autenticação, configurar filtros de segurança, etc. Você pode especificar as configurações de segurança usando 
   a sintaxe do DSL do Spring Security.

-> `configure(AuthenticationManagerBuilder auth)`: Este método permite configurar a forma como a autenticação dos usuários é tratada. 
   Você pode definir detalhes sobre a origem dos usuários, como uma tabela de usuários em um banco de dados, serviço LDAP ou outro 
   provedor de autenticação personalizado. Você também pode configurar a codificação de senhas, fornecer detalhes sobre os usuários e 
   seus papéis, entre outras opções relacionadas à autenticação.

-> `configure(WebSecurity web)`: Este método é usado para configurações de segurança relacionadas a recursos estáticos, como arquivos 
   CSS, JavaScript, imagens, etc. Aqui, você pode especificar caminhos que devem ser ignorados pelo mecanismo de segurança do Spring.

Ao estender a classe `WebSecurityConfigurerAdapter`, você pode combinar e personalizar esses métodos para atender aos requisitos de 
segurança específicos do seu aplicativo. Você pode adicionar regras de autorização, definir como os usuários são autenticados, 
configurar diferentes mecanismos de autenticação, como login baseado em formulário, autenticação baseada em token, autenticação OAuth, 
entre outros.

A classe `WebSecurityConfigurerAdapter` também funciona em conjunto com outras anotações do Spring Security, como `@EnableWebSecurity`, 
que habilita a configuração de segurança baseada em `WebSecurityConfigurerAdapter`, e `@EnableGlobalMethodSecurity`, que permite a 
segurança a nível de método.

Em resumo, a classe `WebSecurityConfigurerAdapter` do Spring Security fornece uma base conveniente para configurar a segurança em um 
aplicativo web. Ela permite personalizar as regras de segurança, autenticação e autorização para proteger os endpoints do seu aplicativo.


------------------------------------------------------------- // ------------------------------------------------------------

Entendendo Tokens JWT (Json Web Token)

O JWT é um padrão (RFC-7519) de mercado que define como transmitir e armazenar objetos JSON de forma compactada e segura entre 
diferentes aplicações usando a arquitetura REST ou Microserviços ou sendo RestFul e JSON.

Os dados nele contidos podem ser validados a qualquer momento, pois o token é assinado digitalmente e sua validação é feita a cada 
requisição. Ele é formado por três seções: Header, Payload e Signature.

 -> Header - Define informações sobre o tipo de token, nesse caso o JWT.
 
 -> Payload - Contém as informações da entidade autorizada, no caso o usuário que fez o login.
 
 -> Signature - A assinatura é a junção de todas as partes somando a uma chave de assinatura ou certificado e tudo é codificado em 
                Base64.
                
Vantagens: Permite a comunicação segura entre diferentes sistemas e integrações e também evita que os dados sejam capturados por rede
e manipulados de forma errada por alguém com más intenções.
 
Mais Detalhes:
JWT (JSON Web Token) é um padrão aberto (RFC 7519) para tokenização de informações em formato JSON, usado para transmitir dados de 
forma segura entre duas partes. Os tokens JWT são amplamente utilizados na autenticação e autorização de APIs e aplicativos web.

Um token JWT consiste em três partes separadas por pontos: o cabeçalho (header), a carga útil (payload) e a assinatura (signature). 
Cada parte é codificada em Base64URL e concatenada com pontos.

- O cabeçalho (header) especifica o tipo de token e o algoritmo de assinatura usado. Ele geralmente inclui informações como o tipo de 
token (JWT) e o algoritmo de criptografia usado, como o HMAC, RSA ou o algoritmo de assinatura digital ECDSA.

- A carga útil (payload) contém as informações do token, como o identificador do usuário, as permissões associadas e quaisquer outros 
dados relevantes. A carga útil pode ser personalizada de acordo com as necessidades do aplicativo.

- A assinatura (signature) é gerada usando a chave secreta do servidor ou uma chave privada, para verificar a integridade dos dados do
 token e garantir que ele não tenha sido alterado. A assinatura é calculada com base no cabeçalho, na carga útil e na chave de 
 assinatura, usando o algoritmo especificado no cabeçalho do token.

Ao receber um token JWT, o servidor pode verificar sua validade e autenticidade verificando a assinatura. Se a assinatura for válida, 
o servidor pode confiar nas informações contidas no token para autenticar o usuário e conceder acesso aos recursos solicitados.

Uma das principais vantagens dos tokens JWT é a portabilidade e a facilidade de uso em ambientes distribuídos. Os tokens são 
autossuficientes, ou seja, todas as informações necessárias estão contidas no próprio token, o que elimina a necessidade de consultar 
um banco de dados ou armazenar informações de sessão no servidor. Isso torna os tokens JWT escaláveis e adequados para arquiteturas 
de microsserviços e APIs RESTful.

Além disso, os tokens JWT são assinados digitalmente, o que garante a integridade dos dados e impede a manipulação por parte de 
terceiros. No entanto, é importante garantir a segurança das chaves de assinatura e proteger o token contra ações maliciosas, como 
roubo ou falsificação.

No contexto de autenticação, um fluxo comum usando tokens JWT envolve a geração do token após um processo de autenticação bem-sucedido 
(geralmente com nome de usuário e senha). O token é então enviado para o cliente e incluído nas solicitações subsequentes como um 
cabeçalho de autorização. O servidor valida o token a cada solicitação e concede acesso aos recursos protegidos.

Em resumo, os tokens JWT são uma forma popular de autenticação e autorização em aplicativos web e APIs. Eles fornecem uma maneira 
segura e portável de transmitir informações entre duas partes, garantindo a integridade e autenticidade dos dados.
 
 
< Exemplificando abaixo um token JWT com a parte do cabeçalho (header) > 

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

Nesse exemplo, o cabeçalho é representado por uma string codificada em Base64URL: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`.

Ao decodificar essa string em Base64URL, obtemos o seguinte JSON:


{
  "alg": "HS256",
  "typ": "JWT"
}


Aqui está a descrição das propriedades do cabeçalho:

- `alg`: Indica o algoritmo de assinatura utilizado para gerar a assinatura do token. Neste exemplo, o valor é "HS256", que 
         corresponde ao algoritmo HMAC-SHA256.

- `typ`: Indica o tipo de token. Neste caso, o valor é "JWT", indicando que é um JSON Web Token.

Essas informações no cabeçalho são usadas pelo servidor para entender como a assinatura do token foi gerada e como ela pode ser 
verificada.

É importante ressaltar que o cabeçalho de um token JWT não contém informações sensíveis ou privadas. Seu propósito principal é 
informar ao servidor sobre o tipo e o algoritmo usado no token. As informações confidenciais, como o identificador do usuário e as 
permissões, são geralmente incluídas na carga útil (payload) do token.

Lembre-se de que o exemplo acima é apenas uma representação do cabeçalho em formato codificado. Em um cenário real, o token completo 
seria composto pelo cabeçalho, a carga útil e a assinatura, todos separados por pontos e codificados em Base64URL.



                                   < JWT - Funcionamento e estrutura >
                                 
         Cliente Navegador                                                        Servidor Back-end
           
              |                 1º Cliente faz o login passando o usuário e senha           |       2º - Valida usuario e senha 
              | --------------------------------------------------------------------------> |    |      e gera o JWT secreto 
              |                                                                             |    |
              |                 3º Servidor retorna o JWT para o usuário                    |    V
              | <-------------------------------------------------------------------------- |    
              |                                                                             |
              |                 4º Envia o JWT nas próximas solicitações                    |
              | --------------------------------------------------------------------------> |
              |                                                                             |    | 5º - Valida e libera acesso
              |                                                                             |    |             a API
              |                                                                             |    |                                                                 
              |                  6º Retorno é enviado ao navegador/usuário                  |    V
              | <-------------------------------------------------------------------------- |    
          
          
          
          
                                   < Estrutura de classes JWT Token>
                                   
[OBS. Podemos implementar na seguinte ordem: 1º, 2º, 3º e 4º.]
                                   
                                   
 Estende de AbstractAuthenticationProcessingFilter                                 Estende de GenericFilterBean é o nosso 
     e estabelece o nosso gerenciador de Token                                      filto que captura as requisições e
        (2º)                                                                                   diz para autenticar  (3º)
               |----------------|                                                     |---------------------------|             
               | JWTLoginFilter | <-----------------------         -----------------> | JWTAPIAutenticationFilter |                                                                              
               |----------------|                        |        |                   |---------------------------|                
                        |                                |        |                                    |
                        |                                |        |                                    |
                        |                                |        |                                    |
                        |                                |        |                                    |
                        |                         |-------------------|                                |
                        |                         | WebConfigSecurity |                                |
                        |                         |-------------------|                                |
                        |                                                                              |
                        |                     Mapeia toda a parte de segurança                         |
                        |                      e registra as classes de token  (4º)                    |
                        V                                                                              |
               |-----------------------------|                                                         |
               | JWTTokenAutenticacaoService | <--------------------------------------------------------             
               |-----------------------------|  
             
             Gera o nosso token e também valida 
                      o token enviado                      
                   (1º)                
                                   
--------------------------------------------------------- // ----------------------------------------------------------------
                           
Bom saber sobre a interface ApplicationContextAware:

A interface ApplicationContextAware é uma interface fornecida pelo Spring Framework que permite que uma classe seja informada 
sobre o contexto do aplicativo Spring em que está sendo executada. Ao implementar essa interface, a classe se torna ciente do 
contexto de aplicativo e pode interagir com ele.

A interface ApplicationContextAware define um único método: 

void setApplicationContext(ApplicationContext applicationContext) throws BeansException {...}

Esse método é chamado pelo contêiner do Spring assim que o contexto do aplicativo é criado e pronto para uso. O próprio 
contêiner injeta o contexto do aplicativo nesse método, permitindo que a classe tenha acesso ao contexto e utilize suas 
funcionalidades.

Ao implementar a interface ApplicationContextAware e fornecer uma implementação para o método setApplicationContext, é possível 
realizar várias tarefas, como:

 -> Acesso a beans gerenciados: A classe pode usar o contexto do aplicativo para obter instâncias de beans gerenciados pelo 
                                Spring. Ela pode solicitar ao contexto a instância de um bean específico por meio de seu nome 
                                ou tipo.

 -> Registro de beans personalizados: A classe pode interagir com o contexto do aplicativo para registrar novos beans 
                                      personalizados. Isso pode ser útil em cenários em que um componente precisa ser 
                                      dinamicamente adicionado ao contexto do aplicativo.

 -> Configuração adicional: A classe pode realizar configurações adicionais com base no contexto do aplicativo. Isso inclui 
                            acessar propriedades de configuração, definir valores de configuração específicos do contexto ou 
                            executar ações personalizadas durante o ciclo de vida do aplicativo.

A implementação da interface ApplicationContextAware é uma maneira de obter acesso direto ao contexto do aplicativo Spring. 
No entanto, é importante lembrar que a dependência direta no contexto do aplicativo pode acoplar a classe a um contêiner 
específico e limitar a portabilidade. Portanto, é recomendado usar essa interface com cautela e considerar a necessidade real 
de acesso direto ao contexto do aplicativo. Em muitos casos, é preferível usar a injeção de dependência adequada por meio das 
anotações @Autowired ou @Inject.                            
                                   
----------------------------------------------------------- // --------------------------------------------------------------

A classe `UsernamePasswordAuthenticationToken` é uma implementação da interface `Authentication` fornecida pelo Spring Security. 
Ela é comumente usada para representar uma solicitação de autenticação baseada em nome de usuário e senha.

Essa classe representa as credenciais fornecidas pelo usuário durante o processo de autenticação e encapsula as informações 
necessárias para autenticar o usuário no sistema. Ela contém dois campos principais:

1. **Username (nome de usuário)**: Representa o nome de usuário fornecido pelo usuário durante a autenticação. Geralmente, é 
   uma string que identifica exclusivamente o usuário.

2. **Password (senha)**: Representa a senha fornecida pelo usuário durante a autenticação. É uma string que corresponde à senha 
   associada ao nome de usuário.

Além desses campos, a classe `UsernamePasswordAuthenticationToken` também herda vários outros métodos e propriedades da classe 
`AbstractAuthenticationToken`, como `getAuthorities()`, `getPrincipal()`, `getCredentials()`, entre outros.

O método 'getAuthorities()' retorna uma coleção de objetos GrantedAuthority, que representam as permissões ou papéis atribuídos 
a um usuário autenticado. As permissões podem ser usadas posteriormente para tomar decisões de autorização com base nos 
privilégios concedidos ao usuário.

A interface GrantedAuthority é uma interface básica do Spring Security que define o método getAuthority(), que retorna uma 
representação em string da permissão ou papel. Geralmente, uma permissão é definida como uma string única, como "ROLE_ADMIN" 
ou "ROLE_USER".

A coleção de GrantedAuthority retornada pelo método getAuthorities() pode ser usada em várias situações, como:

 -> Decisões de autorização: As permissões podem ser usadas para controlar o acesso a determinados recursos com base nos 
                             privilégios do usuário. Por exemplo, um método ou uma página pode ser protegido e permitido 
                             apenas para usuários com uma determinada permissão.

 -> Personalização de comportamento: Com base nas permissões atribuídas ao usuário, é possível personalizar o comportamento do 
                                     aplicativo. Por exemplo, exibir ou ocultar certas funcionalidades com base nos privilégios 
                                     do usuário.

Normalmente, a classe `UsernamePasswordAuthenticationToken` é utilizada em conjunto com outros componentes do Spring Security, 
como `AuthenticationManager`, `AuthenticationProvider` e `UserDetailsService`, para realizar o processo de autenticação.

Ao receber as informações de nome de usuário e senha do usuário, é comum criar uma instância de `UsernamePasswordAuthenticationToken` 
com essas informações e passá-la para o `AuthenticationManager`. O `AuthenticationManager` é responsável por validar as 
credenciais do usuário e, se forem válidas, retornar uma instância de `Authentication` preenchida com informações adicionais, 
como as permissões (ou papéis) do usuário.

Em resumo, a classe `UsernamePasswordAuthenticationToken` é usada no Spring Security para representar as credenciais fornecidas 
pelo usuário durante a autenticação baseada em nome de usuário e senha. Ela encapsula o nome de usuário e a senha, e é usada 
em conjunto com outros componentes do Spring Security para realizar o processo de autenticação e autorização de usuários.  

---------------------------------------------------- // --------------------------------------------------------------------

A classe AbstractAuthenticationProcessingFilter é uma classe abstrata fornecida pelo framework Spring Security, que é usado 
para autenticação de usuários em aplicativos web.

Essa classe é uma parte fundamental do processo de autenticação no Spring Security e define o comportamento básico para 
processar solicitações de autenticação. Ela lida com a autenticação de um usuário com base nas informações fornecidas em uma 
solicitação HTTP.

A principal responsabilidade da classe AbstractAuthenticationProcessingFilter é extrair as informações de autenticação 
(como nome de usuário e senha) da solicitação HTTP e enviá-las para um provedor de autenticação para validação. Ela também 
lida com o redirecionamento de usuários após a autenticação bem-sucedida ou a exibição de mensagens de erro em caso de falha 
na autenticação.

A classe AbstractAuthenticationProcessingFilter fornece métodos abstratos que devem ser implementados pelas subclasses para 
definir o comportamento específico da autenticação. Alguns desses métodos incluem:

 -> attemptAuthentication(request, response): Este método é chamado para extrair as informações de autenticação da solicitação 
                                              e retornar um objeto de autenticação (geralmente uma implementação de Authentication) 
                                              que contém essas informações.

 -> successfulAuthentication(request, response, authentication): Este método é chamado quando a autenticação é bem-sucedida. 
                                                                 É aqui que você pode realizar ações adicionais, como a criação 
                                                                 e envio de tokens de autenticação ou o redirecionamento do 
                                                                 usuário para uma página específica.

 -> unsuccessfulAuthentication(request, response, failed): Este método é chamado quando a autenticação falha. Você pode lidar 
                                                           com a falha na autenticação de maneira apropriada, como exibindo uma 
                                                           mensagem de erro ou redirecionando o usuário para uma página de 
                                                           login novamente.

As subclasses da AbstractAuthenticationProcessingFilter devem ser criadas para lidar com um tipo específico de autenticação, 
como autenticação baseada em formulário, autenticação baseada em token ou autenticação com provedores externos, como OAuth.

Geralmente, você estenderá a classe AbstractAuthenticationProcessingFilter para criar sua própria classe de filtro de 
autenticação personalizada, implementando os métodos abstratos necessários e adicionando lógica adicional, se necessário, para 
atender aos requisitos específicos do seu aplicativo.      
          