Acessar a aplicação: http://localhost:8080/
Acessando mapeando o usuario: http://localhost:8080/usuario/ 
   
   
   Evolução dos Serviços

                                 [REST]
                          A era da arquitetura REST 
                       A implementações do REST são o RestFull
                       Microserviços com responsabilidades definidas

                              ^                       ^
                              |                       |
                              |         [SOA]         |
                       Arquitetura Orientado a Serviços (SOA)
                          Comunicação em XML usando SOAP
                              (Extremamente Complexo)
                         
                              ^                       ^
                              |                       |
                              |                       |
                       Sistemas que trocavam informações tinham a 
                 mesma rotina escrita várias vezes por equipes diferentes 
                          (Bagunça na troca de informações)



REST (Representational State Transfer) é um estilo arquitetural usado para projetar sistemas de software distribuídos, especialmente aqueles que envolvem a 
comunicação entre sistemas na web. 


No estilo REST, os recursos são expostos através de URLs (Uniform Resource Locators) e são acessados por meio de operações HTTP, como GET, POST, PUT e DELETE. 
Cada recurso é identificado de forma única por sua URL e pode representar uma entidade de negócio, como um usuário, um produto ou uma postagem em um blog.

Os princípios básicos do REST incluem:

 -> Protocolo HTTP: O REST utiliza o protocolo HTTP como sua base de comunicação. Isso significa que ele aproveita os métodos e códigos de status HTTP, como GET para 
    recuperar um recurso, POST para criar um recurso, PUT para atualizar um recurso e DELETE para remover um recurso.
    Get - Anotação Spring @GetMapping - Pedido para recuperar dados.

 -> Stateless: As solicitações enviadas para um serviço REST devem conter todas as informações necessárias para processá-las. O servidor não deve manter nenhum estado 
    sobre o cliente entre as solicitações, ou seja, não pode ter sessões amarradas. Cada solicitação é tratada de forma independente.
    
    Exemplificando: Diagmos que você é um usuário e se logou e foi feito uma autenticação (login e senha), porém nessa parte em API RestFull entra a  
                    autenticação por tokken (código criptografado) que fica colocado no lado do navegador do usuário e toda vez que o usuário for fazer uma 
                    requisição, por exemplo, salvar um produto, esse tokken (código de validação) que é tipo uma autorização do usuário que tem que ser mandada para 
                    a API o tokken e os produtos salvos do usuário que você quer gravar no BD, então esse processo vai ser feito, ou seja, gravado os dados e gerando
                    a resposta ao usuário que foi salvo o produto com sucesso. Portanto, as sessões não podem ser amarradas, o cliente já tem que ter todos os dados
                    em mãos (na requisição), como o login, a senha, o tokken de validação e os dados para salvar, lembrando, que esses dados virá pela requisição, 
                    logo, o servidor não poderá está dependendo do cliente, esperando-o para autorizá-lo para tais ações.

 -> Operações CRUD: O REST mapeia as operações CRUD (Create, Read, Update, Delete) para os métodos HTTP correspondentes. Por exemplo, o POST é usado para criar um novo
    recurso, o GET é usado para ler um recurso, o PUT é usado para atualizar um recurso existente e o DELETE é usado para remover um recurso.
    
    POST - Anotação Spring @PostMapping - Enviar dados para processar
    PUT - Anotação Spring @PutMapping - Enviar dados para atualizar
    DELETE - Anotação Spring @DeleteMapping - Deletar o registro

 -> Representações: Os recursos em um serviço REST podem ser representados em diferentes formatos, como XML, JSON ou HTML. O cliente pode especificar o formato desejado 
    usando os cabeçalhos HTTP apropriados.

 -> URIs como identificadores de recursos: Cada recurso em um serviço REST é identificado por uma URL única. As URLs são usadas para acessar e manipular os recursos 
    através das operações HTTP.


RESTFull é um termo usado para descrever um serviço web que segue os princípios do estilo arquitetural REST. Um serviço RESTful é aquele que adere às diretrizes e 
boas práticas do REST, fornecendo uma interface consistente e previsível para interações entre sistemas.

[EndPoinnts]
Endpoints são os pontos de extremidade de um serviço web ou API (Interface de Programação de Aplicativos). Eles são as URLs (Uniform Resource Locators) específicas 
usadas para acessar recursos ou executar operações em um serviço web.

Em um serviço web, os endpoints são definidos para cada recurso disponível, indicando a localização e os métodos HTTP permitidos para interagir com esse recurso. 
Cada endpoint geralmente corresponde a uma operação específica que pode ser realizada no serviço.

Por exemplo, considere uma API de um sistema de gerenciamento de usuários. Alguns exemplos de endpoints seriam:

 ->  `/users`: Endpoint para listar todos os usuários registrados. Neste caso, provavelmente o método HTTP utilizado seria o GET.

 ->  `/users/{id}`: Endpoint para obter informações sobre um usuário específico. O parâmetro `{id}` indica que o endpoint espera o ID do usuário como parte da URL. 
     O método HTTP utilizado aqui também seria o GET.

 -> `/users/{id}`: Endpoint para atualizar as informações de um usuário específico. O método HTTP utilizado seria o PUT ou o PATCH.

 -> `/users/{id}`: Endpoint para excluir um usuário específico. O método HTTP utilizado seria o DELETE.

Cada endpoint é uma rota específica dentro da API que determina a ação a ser executada e os recursos envolvidos. Os endpoints são acessados através de uma combinação 
da URL base do serviço e da rota específica definida para cada recurso.

Ao projetar uma API, os endpoints devem ser bem definidos e seguir as convenções estabelecidas para garantir uma interface clara e consistente para os clientes que 
desejam interagir com o serviço web.

Exemplificando: Tem o sistema de mercado e você quer disponibilizar em uma arquitetura de API, logo você terá que reescrever as regras de negócio da usa linguagem 
de programação e que dê suporte a web. Você vai criar o seu projeto em forma de API, colocar num servidor de hospedagem e integrar o Banco de Dados e fazer as suas 
interfaces (tela) para o usuário acessar. O usuário só vai fazer as requisições para acessar as informações do servidor e retornando para o usuário.

                                 < Integração de vários projetos em uma API >

  --------------------------    Requisições (endpoints)
  | [ Servidor Hospedagem ] |  <------------------------ [ sistema web ]
  |         +               |  <------------------------ [ sistema desktop ]    <----------------->[ Usuário ]
  |    [ Banco de Dados ]   |  <------------------------ [ aplicativo mobile ]
  |-------------------------|
     Projeto em API
      WebServices
   

                       < Sistema em Arquitetura em REST / RestFull >


           [ Front End ]                                           [ Back End ]
               JQuery        Pedido feito para o servidor             Java
               PrimeUI    -------------------------------------->     PHP
               Angular                                                C#
               VueJS                Ajax + JSON                       Ruby
               React         Retorno de dados em JSON                 Python
               Outros    <---------------------------------------     Go
                                                                      Outros

OBS. Só o JSON é a resposta do pedido de processamento do servidor. Não retorna mais numa página com dados, agora é retornado somente o JSON.
     Ou seja, é pedido e resposta em ajax e JSON, com isso, não deixa a arquitetura amarrada, contudo é possível construir a nossa estrutura 
     com back-end em qualquer uma das liguagens dita acima e do outro lado, no front-end, também qualquer uma das linguagens dita acima. Outro,
     detalhe é que é possível trocar a tecnologia tanto do front-end quanto do back-end sem que sofra problemas de compatibilidade. É possível 
     também reutilizar tanto o front-end quanto o back-end para conectar com vários front-end ou vários back-end.
 
Benefícios: 
    -> Reutilização de Códigos;
    -> Acessível por qualquer tecnologia;
    -> Baixo consumo do servidor, ou seja, (1) faz a requisição (2) o ajax processo (3) devolve a requisição (4) Finish;
    -> Fácil Manutenção;
    -> Fácil implementação de recursos;
    -> Front-End desamarrado com o back-end, ou seja, é possível trocar a tecnologia do front-end sem que sofra alterações no back-end;
        OBS. Por exemplo, o MVC é uma arquitetura amarrada, pois precisa dessa integração entre o front-end e back-end, ou seja, em MVC 
             tem que retornar uma página junto com os dados.
    -> Back-End desamarrado com o front-end, ou seja, é possível trocar a tecnologia do back-end sem que sofra alterações no front-end;
    -> Alta escalabilidade;
    -> Outros.

                                                     < Modelagem Correta de URIs >

OBS. URI - É como será acessado os nossos métodos RestFull.

OBS. As requisições abaixos serão acessadas por um navegador pelo um framework em javascript. Serão passados um paramêtro (verbo) HTTP e a URI que 
     definirá a ação.



            [ URI criada de forma ERRADA ]                                          [ URI criada de forma CERTA ]
   
                     RPC (POX)                                                                   REST
-----------------------------------------------------                   -----------------------------------------------------
| Verbo HTTP  |       URI           |      Ação      |                  | Verbo HTTP  |       URI           |      Ação      |
-----------------------------------------------------                    -----------------------------------------------------
|    GET      | /buscarCliente/1    |   Visualizar   |                  |    GET      |      /cliente/1     |   Visualizar   |
-----------------------------------------------------                    -----------------------------------------------------
|   POST      | /salvarCliente/1    |   Criar        |                  |   POST      |      /cliente       |   Criar        |
-----------------------------------------------------                    -----------------------------------------------------
|   POST      | /alterarCliente/1    |   Alterar     |                  |   PUT       |      /cliente/1     |   Alterar     |
-----------------------------------------------------                    -----------------------------------------------------
| GET/POST    | /deletarCliente/1    |   Remover     |                  |   DELETE    |       /cliente/1    |   Remover     |
-----------------------------------------------------                    -----------------------------------------------------

OBS. A implementação feita de forma errada pode gerar 
     quebra do sistema, de padrões, sem falar que também
     não pode expor a sua URI para possíveis invasores mal
     intencionados.

         @RestController
         @RestMapping("/cliente")
         public class PessoaController{
              
                @GetMapping("/{cpf}")
                public ResponseEntity<Pessoa> buscarPessoa(@PathVariable("cpf") String cpf){
                
                       System.out.println("Aqui processa a consulta no banco de dados");

                       return new ResponseEntity<Pessoa>(new Pessoa(), HttpStatus.OK);
                }
        }


                                      < Regras da API RestFull >

 1. Tem que existir os dois papéis, o cliente (Navegador - front-end) e o servidor (API - back-end).
 
 2. Stateless, o sistema não pode ter sessões amarradas/ criadas para o cliente e as requisições tem que todos os dados 
    para o processo ser realizado e a resposta ser completa.

 3. Precisa permitir que o cache seja feito caso necessário.

 4. Interface uniforme - a API não pode fazer distinção de clientes, não pode diferenciar e processar algo diferente para 
    o navegador, desktop ou mobile. Ou seja, a API não pode saber qual é o tipo de cliente, se ele é um navegador, ou um desktop
    ou um mobile.

 5. Sistemas em camadas, entre o cliente e a API deves ser possível adicionar algum serviço como log da aplicação.

 6. Código sobre demanda, por exemplo, o javascript importado direto do servidor da API.

-------------------------------------------------//------------------------------------------------------------

Mapeamentos:

 1. @EntityScan(basePackages = {"projeto.api.rest.model"})
    Vai ler todas as classes que estiverem nesse pacote de modelo para criar automaticamente no banco de dados.
    
 2. @ComponentScan(basePackages = {"projeto.*"})
    Para injeção de dependencia para o Spring controlar todos os nossos objetos. Vai entrar em todas as pastas 
    denominado 'projeto' e vai sair varrendo configurando todo o nosso projeto automaticamente em relação a 
    injeção de dependencia.
    
 3. @EnableJpaRepositories(basePackages = {"projeto.api.rest.repository"})
   Habilitar a parte de repositório para as funcionalidades do CRUD 
    
 4. @EnableTransactionManagement
   Corresponde no controle das transações no banco de dados, transaçoes na hora de inserir, deletar, ...
   São as gerencias de transações.
   
 5. @EnableWebMvc
   Caso eu queira trabalhar com a estrutura MVC - ativa a parte de MVC.
   
 6. @RestController
   Para saber que é um projeto Rest e que é para retornar JSON nas requisições.
   
 7. @EnableAutoConfiguration
    Para ativar todas essas configurações de mapeamento e manter tudo funcionando.
 
    
 Todas essas anotações é o suficiente para manter o funcionamento de projetos Rest Spring Boot.
 
 --------------------------------------------- // -----------------------------------------------------------

Tem que aplicar essas propriedades no application.properties para corrigir esse erro: 
java.sql.SQLFeatureNotSupportedException - é um erro que não prejudica a aplicação, no caso, é um 
erro de conexão de JDBC. Portanto, para resolver basta adicionar as duas propriedades abaixo.

propriedades:

spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults = false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

IMPORTANTE!!!
Link da documentação do application.properties:
https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html


-------------------------------------------- // -------------------------------------------------------------

Vale ressaltar que vamos utilizar as bibliotecas javax para as funcionalidades do JPA. Porém ao criar o projeto por
padrão são adicionados as bibliotecas do jakarta. Logo, para fazer essa remorção do jakarta temos que mudar a versão
do Spring na tag parent para 2.1.2.RELEASE no arquivo pom.xml, dessa forma o javax será provido em seu projeto sem ser 
necessário adicionar nenhuma dependência extra! 
Exemplificando - lá no pom.xml

<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.1.RELEASE</version>
		<relativePath /> <!-- lookup parent from repository -->
</parent>

Outro Detalhe: Modifiquei para java 1.8. 

---------------------------------------------- // ---------------------------------------------------------------
Exemplificando a codificação: 

1. `@RestController`: É uma anotação usada no Spring Boot para indicar que essa classe é um controlador REST, responsável por lidar com as 
    solicitações HTTP e retornar as respostas adequadas.

2. `@RequestMapping(value = "/usuario")`: É uma anotação que especifica o caminho base para todas as solicitações HTTP manipuladas por esse 
    controlador. Nesse caso, todas as solicitações começando com "/usuario" serão tratadas por este controlador.

3. `public class IndexController`: É a definição da classe do controlador.

4. `@GetMapping(value = "/", produces = "application/json")`: É uma anotação que especifica que esse método será acionado por uma solicitação GET HTTP 
    para a rota especificada. Neste caso, o método `init` será acionado quando a solicitação for enviada para "/usuario/".

5. `public ResponseEntity init(@RequestParam(value = "nome") String nome)`: É a definição do método `init`, que recebe um parâmetro chamado "nome" através 
    de uma solicitação GET. O valor desse parâmetro é armazenado na variável `nome` do tipo `String`. O retorno do método é uma instância de `ResponseEntity`, 
    que é uma classe que representa uma resposta HTTP personalizada.

6. `System.out.println("Parâmetro sendo recebido " + nome);`: Essa linha imprime no console uma mensagem contendo o valor do parâmetro "nome" recebido na 
    solicitação GET.

7. `return new ResponseEntity("Olá usuário Rest Spring Boot, seu nome é " + nome, HttpStatus.OK);`: Retorna uma nova instância de `ResponseEntity` com uma 
    mensagem de saudação personalizada, que inclui o valor do parâmetro "nome" recebido. O status HTTP retornado é "OK" (código 200).

Em resumo, esse script define um controlador REST que recebe uma solicitação GET em "/usuario/" com um parâmetro "nome" e retorna uma resposta HTTP com uma 
mensagem de saudação personalizada. O valor do parâmetro "nome" é exibido no console antes de retornar a resposta.

Passando o parametro da aplicação como exemplo: http://localhost:8080/usuario/?nome=Daniel

Podemos utilizar o 'defaultValue' para caso onde o cliente esquece de preencher o valor, logo se o cliente esquece de informar o valor,
o serviço irá pegar esse valor default, podendo retornar como resultado para o cliente dando-lhe um aviso para ele.

Podemos utilizar o 'required' como 'false' que torna não obrigatorio o valor a ser passado por parametro. Logo, como o parametro não é
obrigatório, ele assume o valor de null. Lembrando que para o valor 'true' torna obrigatorio o valor do parametro a ser passado.

Passando o parametro da aplicação como exemplo: http://localhost:8080/usuario/?nome=Daniel&salario=5000

------------------------------------------------------------------- // ------------------------------------------------------------

public ResponseEntity<Usuario> init(@PathVariable(value = "id") Long id): Esse é o método init, que recebe um parâmetro id através 
de uma variável de caminho (path variable) usando a anotação @PathVariable. A anotação @PathVariable indica que o valor do id será 
extraído do caminho da URL. O tipo do parâmetro é Long. O retorno do método é uma instância de ResponseEntity que encapsula um 
objeto do tipo Usuario.

Para testar vamos inserir alguns valores no banco de dados:
INSERT INTO public.usuario(
            id, login, nome, senha)
    VALUES (1, 'daniel', 'Daniel', '123');

INSERT INTO public.usuario(
            id, login, nome, senha)
VALUES (2, 'biana', 'Biana', '123');

INSERT INTO public.usuario(
            id, login, nome, senha)
VALUES (3, 'walter', 'Walter', '123');

uri: http://localhost:8080/usuario/1

------------------------------------------------------------------- // ------------------------------------------------------------
Exemplificando a codificação: 

1. `@PostMapping(value = "/", produces = "application/json")`: Essa é uma anotação utilizada no Spring Boot para mapear o método 
   `cadastrar` a uma solicitação HTTP POST. Ela especifica que o método será acionado quando uma solicitação POST for enviada para 
    a rota "/". A opção `produces = "application/json"` indica que a resposta será em formato JSON.

2. `public ResponseEntity<Usuario> cadastrar(@RequestBody Usuario usuario)`: Esse é o método `cadastrar` que recebe um objeto 
   `Usuario` como parâmetro. A anotação `@RequestBody` indica que o objeto `Usuario` será extraído do corpo (body) da solicitação 
    POST. O retorno do método é uma instância de `ResponseEntity` que encapsula um objeto do tipo `Usuario`.

3. `Usuario usuarioSalvo = usuarioRepository.save(usuario)`: Nesta linha, o objeto `usuario` recebido como parâmetro é salvo no 
    banco de dados usando o método `save` do objeto `usuarioRepository`. O método `save` retorna o objeto `Usuario` salvo, que é 
    armazenado na variável `usuarioSalvo`.

4. `return new ResponseEntity<Usuario>(usuarioSalvo, HttpStatus.OK)`: Aqui, é criada uma instância de `ResponseEntity`, passando o 
   objeto `usuarioSalvo` como primeiro argumento e `HttpStatus.OK` como segundo argumento. O `HttpStatus.OK` indica que a solicitação 
   foi bem-sucedida, com código de status HTTP 200. O objeto `usuarioSalvo` será retornado como resposta da solicitação POST.

Em resumo, esse script define um método `cadastrar` que é acionado por uma solicitação HTTP POST na rota "/". O método recebe um 
objeto `Usuario` no corpo da solicitação, salva esse objeto no banco de dados e retorna uma resposta HTTP com o objeto `Usuario` 
salvo e o código de status HTTP 200 (OK).

------------------------------------------------------------------- // ------------------------------------------------------------

Configuração de contexto da nossa aplicação, ou seja, seria a nossa url do projeto. O contexto é configurado no application.properties.
Propriedade:
server.servlet.context-path=/projetospringrestapi

Portanto, o nosso contexto ficou assim agora:
http://localhost:8080/projetospringrestapi/
http://localhost:8080/projetospringrestapi/usuario/


---------------------------------------------------------------------- // -------------------------------------------

Vamos criar um Builder para startizar o nosso projeto automaticamente, para fazer isso vamos gerar um Jar executável 
da Aplicação Spring Boot.

1º Vamos modificar o nosso packaging de 'war' para jar. Logo vai ficar assim:
<packaging>jar</packaging>

2º Vamos copiar o caminho de endereço a partir da pasta 'target', para isso:
   clica com o botão direito em cima da pasta target > properties > Resources > Location: Show In System Explorer (copia o caminho da pasta )
   Por exemplo: C:\Users\d4nan\git\repository12\projetospringrestapi
   
3º Vamos abrir o prompt de comando: cmd

4º Vamos acessar essa pasta, por exemplo:
   cd C:\Users\d4nan\git\repository12\projetospringrestapi
   
5º Vamos criar a Builder para gerar o jar executável
   Comando: mvn package
   
   IMPORTANTE!!! Estava dando erro por causa do arquivo de teste, para resolver esse erro vamos fazer um skip para pular
   esse arquivo de teste.
   Comando:  mvn clean package -DskipTests
   
6º Clica na pasta target ou no projeto e aperta o F5 para atualizar, vai ser criado o jar do projeto na pasta target.   
   
7º Vamos agora executar o jar para que ele fique executável para a aplicação Spring Boot.
   No prompt de comando (cmd) vamos acessar agora a pasta target.
   Comando: cd target
   
   Depois vamos inserir o comando do jar criado: java -jar <nome do jar criado>
   OBS: Podemos acessar esse o jar clicando em cima 'projetospringrestapi-0.0.1-SNAPSHOT.jar' e com o botão 
        direito do mouse vai em properties > Resources > Location: Show In System Explorer (copia o nome do jar do projeto)  
   Comando: java -jar projetospringrestapi-0.0.1-SNAPSHOT.jar 
   
   Vale ressaltar se fechar o prompt de comando (cmd) vai morrer o processo.
   
   Para executar o processo de novo temos que:
   Acessar o prompt de comando (cmd) e acessar a pasta target:
   comando: cd C:\Users\d4nan\git\repository12\projetospringrestapi\target
   executar o jar comando: java -jar projetospringrestapi-0.0.1-SNAPSHOT.jar
   
   Podemos também executar o processo diretamente no jar criado, porém NÃO É ACONSELHÁVEL, pois não terá o prompt 
   para visualzar os logs, uma vez que precisamos dele para descobrir erros que podem ocasionar na nossa api quando
   estiver implementando. Lembrando que para executar o jar criado basta ir na pasta onde ele se encontra e clicar
   nele para ser executado. (caminho: C:\Users\d4nan\git\repository12\projetospringrestapi\target)
   
   Por isso o correto é acessar pelo prompt de comando e acessar a pasta target:
   comando: cd C:\Users\d4nan\git\repository12\projetospringrestapi\target
   executar o jar comando: java -jar projetospringrestapi-0.0.1-SNAPSHOT.jar 
   
   É possível acessar a sua API por outros sistemas ou pelo mobile basta utilizar o link - seria uma intranet
   simulando um servidor:
   http://<ipconfig>:8080/projetospringrestapi/
   
   --------------------------------------------------- // ------------------------------------------------------------------
   
Criando o POST no postman:
   
{
   "id": "",
   "login": "joao",
   "senha": "123",
   "nome": "João",
   "telefones": [{"id":"", "numero":"(21) 9944-9223"}, {"id":"", "numero":"(21) 9256-3990"}]
}

Exemplo de delete no postman:
http://localhost:8080/projetospringrestapi/usuario/20/

Exemplo atualizar (PUT) no postman: http://localhost:8080/projetospringrestapi/usuario/

Alterando apenas os dados do usuário:
{
    "id": 35,
    "login": "vanessa",
    "senha": "123",
    "nome": "Vanessa",
    "telefones": [
        {
            "id": 36,
            "numero": "(21) 9005-9677"
        }
    ]
}


Alterando add um novo telefone:

{
    "id": 37,
    "login": "bolsonaro",
    "senha": "123",
    "nome": "Bolsonaro",
    "telefones": [
        {
            "id": 38,
            "numero": "(21) 9889-9234"
        },
        {
            "id": "",
            "numero": "(21) 9899-9004"
        }
    ]
}

OBS. Também é possível alterar deletando um telefone.

 --------------------------------------------------- // ------------------------------------------------------------------
 
Cross Origin - Controle de acesso a API
 
Por motivos de segurança, os navegadores proíbem chamadas AJAX para recusrsos que residem fora da origem atual.
 
Como uma API Rest é feita para que vários clientes possam acessar, então surgeo controle de acesso denominado CORS.
 
Podemos fazer bloqueios e liberações bem customizadas para cada end-point, para cada controller REST e seus end-points ou até
 mesmo para todo o projeto e seus end-points. 
 
O controle de acesso a recursos de API através da política de mesma origem (Same-Origin Policy) é uma medida de segurança 
implementada pelos navegadores para proteger os usuários contra ataques de scripts maliciosos que poderiam ser executados em sites 
de terceiros. Essa política impede que scripts em um domínio acessem recursos em outro domínio, a menos que os domínios envolvidos 
estejam explicitamente configurados para permitir tal acesso.

No entanto, em alguns casos, pode ser necessário permitir solicitações de origens diferentes, o que é conhecido como Cross-Origin 
Resource Sharing (CORS), ou Controle de Acesso a Origem Cruzada. Isso é comum em aplicativos que expõem APIs para consumo por 
clientes que são hospedados em domínios diferentes. O CORS permite que o servidor especifique quais origens têm permissão para 
acessar seus recursos através de cabeçalhos HTTP.

O Spring Security oferece suporte ao CORS, permitindo que você controle o acesso a recursos de API a partir de origens diferentes. 
Para configurar o controle de acesso a origem cruzada no Spring Security, você pode usar a classe CorsConfiguration para definir a 
política de CORS e, em seguida, configurar um CorsFilter para aplicar essa política.

A configuração básica do CORS no Spring Security envolve a definição de quais origens são permitidas (allowedOrigins), quais 
métodos HTTP são permitidos (allowedMethods), quais cabeçalhos podem ser incluídos nas solicitações (allowedHeaders), se as 
credenciais podem ser enviadas (allowCredentials), entre outras opções. Você também pode definir valores específicos para 
diferentes caminhos da API, se necessário.

Passos:


Vamos criar um arquivo index.html e dentro do index.html vamos add uma JQuery CDN para pegar o código de integração, é para garantir o 
funcionamento do JQuery na  nossa página html. Esse código vai ser pego no endereço:
(https://releases.jquery.com/) na opção 'uncompressed' e colado dentro da tag <head>.

Vamos acessar o index.html através do caminho pelo 'properties':
"file:///C:/Users/d4nan/git/repository12/projetospringrestapi/src/main/webapp/index.html"

OBS. Vai abrir uma página em branco.

Se inspecionar (F12) o navegador você visualizará que houve um bloqueio do arquivo index.html pela a política do CORS. Msg gerada:

Access to XMLHttpRequest at 'http://localhost:8080/projetospringrestapi/usuario/' from origin 'null' has been blocked by CORS policy: 
No 'Access-Control-Allow-Origin' header is present on the requested resource.


Cross Origin - Configuração em controler especifico

Se estiver apenas a anotação '@CrossOrigin' vai permitir que qualquer sistema possa fazer uma requisição, uma vez que por padrão vem 
com o asteristico (*), que permite para todos. Vale ressaltar que podemos configurar essa anotação através das 'origins', podendo 
passar quantas origins quiser. Essa origin permite liberar o acesso para o dominio que estiver determinado por ela. Ou seja, vou estar
amarrando o dominio (servidor) com a minha API, permitindo que apenas o que está configurado na origins possa acessar o meu controller de API, 
ou seja, que apenas esse controller de API só iria receber requisições do que está configurado na origins.

Portanto, a anotação @CrossOrigin é uma anotação fornecida pelo Spring Framework para configurar o suporte ao Cross-Origin Resource 
Sharing (CORS) em um controlador de API ou método específico. Essa anotação permite que você controle o acesso a recursos de API a 
partir de origens diferentes.

Ao usar a anotação @CrossOrigin em um controlador ou método, você pode especificar quais origens são permitidas, quais métodos HTTP 
são permitidos, quais cabeçalhos podem ser incluídos nas solicitações, se as credenciais podem ser enviadas e outras opções relacionadas 
ao CORS.

Você também pode usar a anotação @CrossOrigin no nível do controlador para aplicar a mesma configuração a todos os métodos do 
controlador. Nesse caso, a configuração definida no nível do controlador pode ser substituída por configurações específicas de métodos, 
se necessário.

Além de especificar as origens permitidas e os métodos HTTP permitidos, a anotação @CrossOrigin oferece outras opções, como 
allowedHeaders para especificar quais cabeçalhos são permitidos, exposedHeaders para especificar quais cabeçalhos são expostos nas 
respostas, allowCredentials para permitir o envio de credenciais, maxAge para especificar o tempo máximo de cache das configurações 
CORS, entre outras.

É importante lembrar que ao usar a anotação @CrossOrigin, você precisa considerar as implicações de segurança e garantir que seu 
aplicativo esteja adequadamente protegido contra ataques. Você deve configurar as opções de CORS de acordo com suas necessidades 
específicas e garantir que seu aplicativo esteja protegido contra vulnerabilidades conhecidas associadas ao CORS.

Em resumo, a anotação @CrossOrigin é usada para configurar o suporte ao Cross-Origin Resource Sharing (CORS) em controladores de API 
do Spring. Ela permite que você especifique as origens permitidas, os métodos HTTP permitidos, os cabeçalhos permitidos e outras opções 
relacionadas ao CORS em nível de controlador ou método específico.

Como foi dito é possível especificar quais origins são permitidas, quais end-points (métodos HTTP) são permitidos, por exemplo, no 
método 'listaUsuario' vai ser permitido apenas requisições ajax que partirem do servidor 'https://www.google.com/' e 
'https://www.w3schools.com/' que vão poder acessar o método 'listaUsuario' e consumir os seus dados.

O objetivo da CrossOrigin é para pemitir apenas acesso(s) a domínio(s) que está(ão) estipulado em sua regra de negócio, ninguém poderá 
saber que existe essa API para quem não está definido em sua regra de negócio, somente saberá aqueles que estarão configurados através 
da 'origins' que estarão definidos em sua regra de negócio, somente esses poderão consumir os dados da sua API, ou seja, o intuito é 
amarrar a origem e o destino.


Cross Origin - Configuração centralizada (Para Mapeamento Global que refletem em todo o sistema)

O método addCorsMappings é um método fornecido pela interface WebMvcConfigurer do Spring Framework. Esse método é usado para adicionar 
configurações de CORS (Cross-Origin Resource Sharing) ao aplicativo Spring MVC.

O CORS é uma política de segurança implementada pelos navegadores para restringir solicitações de recursos de uma origem (domínio) 
diferente. Ele impede que um script em uma página da web faça solicitações para outra origem, a menos que essa origem tenha configurado 
as permissões de acesso adequadas.

O método addCorsMappings permite que você defina mapeamentos de URL para aplicar as configurações de CORS a caminhos específicos do 
seu aplicativo. Por exemplo, você pode permitir que um caminho específico aceite solicitações de uma origem diferente.

No exemplo, dado no 'ProjetospringrestapiApplication.java' o método addCorsMappings está sendo usado para configurar o CORS para 
qualquer URL que comece com "/usuario/**". Estamos permitindo solicitações apenas da origem "https://google.com", permitindo apenas os 
métodos GET e POST, permitindo os cabeçalhos "Authorization" e "Content-Type", permitindo o envio de credenciais e definindo um 
tempo máximo de cache de 3600 segundos.

Com essa configuração, as solicitações CORS para URLs que correspondam ao padrão "/usuario/**" serão permitidas somente da origem 
especificada, com os métodos, cabeçalhos e outras configurações definidas.

É importante observar que o uso do método addCorsMappings é apenas uma forma de configurar o CORS no Spring MVC. Existem outras 
opções para configurar o CORS, como o uso da anotação @CrossOrigin em controladores individuais. Você pode escolher a opção mais 
adequada com base nas necessidades do seu aplicativo.

Em resumo, o método addCorsMappings é usado para adicionar configurações de CORS ao aplicativo Spring MVC. Ele permite definir 
mapeamentos de URL e configurar as origens permitidas, métodos HTTP permitidos, cabeçalhos permitidos, envio de credenciais e outras 
opções relacionadas ao CORS para caminhos específicos do aplicativo.

-------------------------------------------------- // -------------------------------------------------------------

Spring Security - Configurando ROLE

Bom saber - Anotações:

A anotação @SequenceGenerator é usada para gerar valores sequenciais para a chave primária da tabela. Nesse caso, a sequência é 
chamada "seq_role" e possui um valor inicial de 1 e um tamanho de alocação de 1.

sequenceName -> cria uma sequencia;
allocationSize -> seja gerado de um em um;
initialValue -> inicia com o valor 1;

Para aplicar o Spring Security vamos ter que fazer implementar uma interface 'GrantedAuthority', por padrão tem que add o método
'getAuthority()' do tipo String. Este método retorna o nome do papel, ou seja, o acesso ou a autorização, por exemplo, ROLE_GERENTE.

A classe Role implementa a interface GrantedAuthority da biblioteca Spring Security. Essa interface representa a autoridade ou papel 
de um usuário em um sistema.

O método getAuthority() é necessário para a interface GrantedAuthority e retorna o nome do papel.

Em resumo, essa classe representa uma entidade "Role" com um identificador único (id) e um nome de papel (nomeRole). A classe também 
implementa a interface GrantedAuthority para ser utilizada em um sistema de segurança, retornando o nome do papel através do método 
getAuthority().

----------------------------------------------------- // --------------------------------------------------------------------

Spring Security - Configurando Usuário

Vamos retirar o implements Serializable e colocar o 'UserDetails' que no caso já vem com um Serializable nela.

A interface `UserDetails` faz parte do framework Spring Security e é usada para representar informações sobre um usuário autenticado 
no sistema. Ela encapsula detalhes sobre o usuário, como seu nome, senha, autorizações (papéis/roles), status de conta e outras 
informações relevantes.

A principal função da interface `UserDetails` é fornecer essas informações ao Spring Security durante o processo de autenticação e 
autorização. Quando um usuário faz login no sistema, o Spring Security precisa obter os detalhes desse usuário para verificar sua 
autenticidade e determinar quais recursos e ações ele tem permissão para acessar.

A interface `UserDetails` define vários métodos que precisam ser implementados, como:

- `getUsername()`: Retorna o nome de usuário do usuário.
- `getPassword()`: Retorna a senha do usuário.
- `getAuthorities()`: Retorna uma coleção de objetos `GrantedAuthority`, que representam as autorizações ou papéis do usuário.
- `isEnabled()`: Verifica se a conta do usuário está habilitada.
- `isAccountNonExpired()`: Verifica se a conta do usuário não está expirada.
- `isAccountNonLocked()`: Verifica se a conta do usuário não está bloqueada.
- `isCredentialsNonExpired()`: Verifica se as credenciais do usuário não estão expiradas.

Além desses métodos, a interface `UserDetails` possui outros métodos relacionados a informações adicionais do usuário, como nome 
completo, e-mail, informações de contato, etc.

Ao implementar a interface `UserDetails`, você fornece ao Spring Security uma maneira de acessar e utilizar os detalhes do usuário 
durante o processo de autenticação e autorização, garantindo a segurança adequada do sistema.

Temos o método: public Collection<? extends GrantedAuthority> getAuthorities(){...}. 
Vamos analisar o que ele faz:

Este método retorna uma coleção de objetos que implementam a interface GrantedAuthority. A declaração 
Collection<? extends GrantedAuthority> indica que o método retorna uma coleção de qualquer tipo que seja ou estenda a interface 
GrantedAuthority. O uso de ? extends GrantedAuthority permite que diferentes implementações de GrantedAuthority sejam retornadas.

Vai retornar uma coleção real de autorizações. Normalmente, em um sistema real, você implementaria a lógica dentro desse método para 
recuperar as autorizações (ou papéis) do usuário. Isso pode ser feito consultando o banco de dados ou qualquer outra fonte de dados 
para obter as informações de autorização associadas ao usuário autenticado.

A idéia geral é que esse método retorne uma coleção de objetos GrantedAuthority que representam os papéis ou autorizações do usuário. 
Essas autorizações são usadas pelo Spring Security para determinar quais recursos e ações o usuário tem permissão para acessar.

Vamos entender essa anotação declarada na List<Roles> roles:

@JoinTable(
    name = "usuarios_role",
    uniqueConstraints = @UniqueConstraint(
        columnNames = {"usuario_id", "role_id"},
        name = "unique_role_user"
    ),
    joinColumns = @JoinColumn(
        name = "usuario_id",
        referencedColumnName = "id",
        table = "usuario",
        foreignKey = @ForeignKey(
            name = "usuario_fk",
            value = ConstraintMode.CONSTRAINT
        )
    ),
    inverseJoinColumns = @JoinColumn(
        name = "role_id",
        referencedColumnName = "id",
        table = "role",
        foreignKey = @ForeignKey(
            name = "role_fk",
            value = ConstraintMode.CONSTRAINT
        )
    )
)

A anotação @JoinTable é usada em mapeamentos Many-to-Many em entidades JPA para especificar a tabela de junção que será usada para 
associar duas entidades.

name = "usuarios_role": Especifica o nome da tabela de junção que será criada para associar as entidades "usuarios" e "role". Neste 
caso, a tabela será chamada "usuarios_role".

uniqueConstraints: Permite definir uma ou mais restrições de unicidade para as colunas da tabela de junção. No exemplo, é definida 
uma restrição de unicidade composta pelas colunas "usuario_id" e "role_id" e é atribuído o nome "unique_role_user" para essa restrição.

joinColumns: Especifica as colunas da tabela de junção que se referem à entidade "usuario". No exemplo, é definida uma coluna chamada 
"usuario_id" que se refere à coluna "id" da tabela "usuario". A anotação @JoinColumn também permite especificar o nome da tabela, 
caso seja diferente do nome padrão da entidade. Além disso, é definida uma restrição de chave estrangeira com o nome "usuario_fk" 
usando @ForeignKey e ConstraintMode.CONSTRAINT.

inverseJoinColumns: Especifica as colunas da tabela de junção que se referem à entidade "role". No exemplo, é definida uma coluna 
chamada "role_id" que se refere à coluna "id" da tabela "role". Assim como em joinColumns, é definida uma restrição de chave 
estrangeira com o nome "role_fk".

Essa anotação em conjunto com @ManyToMany é utilizada para estabelecer um relacionamento muitos-para-muitos entre as entidades 
"usuarios" e "role" através de uma tabela de junção intermediária chamada "usuarios_role". Essa tabela armazena os registros que 
associam um usuário a um ou mais papéis. As colunas "usuario_id" e "role_id" na tabela de junção são usadas para referenciar os 
identificadores das entidades "usuario" e "role", respectivamente.

